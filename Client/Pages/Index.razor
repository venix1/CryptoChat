@page "/"
@page "/chat"
@using Microsoft.AspNetCore.SignalR.Client
@using System.Security.Cryptography
@using CryptoChat.Shared;
@using System.Linq;
@inject IJSRuntime jsRuntime
@inject NavigationManager NavigationManager
@implements IDisposable

@* TODO: Figure out how to split this into multiple components *@

@if (!HasGroup) { 
<div class="form-group">
    <label>
        User:
        <input @bind="userInput" />
    </label>
</div>
<div class="form-group">
    <label>
        Group:
        <input @bind="groupInput" />
    </label>
</div>
<div class="form-group">
    <label>
        Password:
        <input @bind="passwordInput" />
    </label>
</div>
<button @onclick="Connect" disabled="@(!IsConnected)">Connect</button>
<button @onclick="Verify" disabled="@(!HasGroup)">Verify</button>
}
else {
<div class="chat-app container" >
    <div id="chatbox" class="chatbox row">
        <div id="conversation" class="conversation col-9 card">
            @foreach (var message in messages) {
                <div class="message">@message</div>
            }
            <div id="anchor"></div>
        </div>
        <div id="members" class = "members card col">
            <div>Party Size: ???</div>
            <b>Active:</b>
            <div id="activeMembers">
            @foreach (var peer in group.PeerList.Where(p => (DateTime.Now - p.LastActive).TotalSeconds <= 90)) {
                <div class="member d-flex justify-content-end" data-toggle="tooltip" data-placement="top" title="Last Active: @peer.LastActive" >@peer.Name</div>
            }</div>
            <b>Inactive:</b>
            <div id="inactiveMembers">
            @foreach (var peer in group.PeerList.Where(p => (DateTime.Now - p.LastActive).TotalSeconds > 90)) {
                <div class="member d-flex justify-content-end" data-toggle="tooltip" data-placement="top" title="Last Active: @peer.LastActive" >@peer.Name</div>
            }
            </div>
        </div>
    </div>
    <div class="row">
    <div class="messageBox col card">
        <span><input placeholder="Your message..." @bind="messageInput" @onkeyup="Send" /></span>
    </div>
    </div>
</div>
}
@code {
    private HubConnection hubConnection;
    private List<string> messages = new List<string>();
    private string userInput;
    private string groupInput;
    private string passwordInput;
    private string messageInput;
    private Guid channelId;

    private MegolmGroup group;

    protected byte[] Desalinate(byte[] salt, byte[] data) {
        byte[] ikm = System.Text.Encoding.UTF8.GetBytes(passwordInput);
        byte[] info = System.Text.Encoding.UTF8.GetBytes(groupInput);
        return MegolmGroup.AesCrypt(ikm, salt, info, false, data);
    }
    protected byte[] Salinate(byte[] salt, byte[] data) {
        byte[] ikm = System.Text.Encoding.UTF8.GetBytes(passwordInput);
        byte[] info = System.Text.Encoding.UTF8.GetBytes(groupInput);
        return MegolmGroup.AesCrypt(ikm, salt, info, true, data);
    }

    protected override async Task OnInitializedAsync() {
        // TODO: Hub shoud CryptedTransport(Generated ECDH)
        hubConnection = new HubConnectionBuilder()
            .WithUrl(NavigationManager.ToAbsoluteUri($"/chathub"))
            .Build();

        hubConnection.On<byte[], byte[]>("ReceiveSession", async (salt, data) => {
            try {

                bool newPeer = group.AddPeer(Desalinate(salt, data));
                Console.WriteLine($"AddPeer: {newPeer}");
                if (newPeer) {
                    salt = MegolmGroup.GetRandomBytes(32);

                    await hubConnection.SendAsync("SendSession", channelId, salt, Salinate(salt, group.Session.Serialize()));
                    StateHasChanged();
                }
                Console.WriteLine("Done");
            }
            catch (Exception e) {
                Console.WriteLine(e);
            }
        });

        hubConnection.On<byte[], byte[]>("ReceiveMeta", async (k, message) => {
            try {
                Console.WriteLine("ReceiveMeta");
                var msg = System.Text.Encoding.UTF8.GetString(group.Decrypt(k, message));

                // TODO: Do something with this someday.
                // For now, use it as a heartbeat
                StateHasChanged();
            }
            catch (Exception e) {
                Console.WriteLine(e);
            }
        });

        hubConnection.On<byte[], byte[]>("ReceiveMessage", async (k, message) => {
            try {
                Console.WriteLine("ReceiveMessage");
                var msg = System.Text.Encoding.UTF8.GetString(group.Decrypt(k, message));

                var update = await Extensions.IsScrolled(jsRuntime, "conversation");
                // update = c.clientHeight + c.scrollTop == c.scrollHeight
                Console.WriteLine(msg);
                var encodedMsg = $"{group.GetPeerName(k)}: {msg}";
                messages.Add(encodedMsg);
                StateHasChanged();

                if (update)
                    await Extensions.ScrollToEnd(jsRuntime, "conversation");
                // if update
                //     document.getElementById('conversation').scrollTo(0, $0.scrollHeight);
            }
            catch (Exception e) {
                Console.WriteLine(e);
            }
        });

        await hubConnection.StartAsync();
    }

    async void Timer() {
        var period = DateTime.UtcNow;
        
        while (true) {
            if ((DateTime.UtcNow - period).TotalSeconds > 60) {
                Console.WriteLine("Timer triggered");
                await SendMeta();
                StateHasChanged();
                period = DateTime.UtcNow;
            }
        
            await Task.Delay(10000);
        }
    }

    Task Verify() {
        // Level 1 TLS is HTTPS.  This can be considered passively transparent.
        // Level 2 is TLS for SignalR.  This is actively transparent.
        // Level 3 is PSK.  This is secure unless a malicious party has stolen.

        // Level 2 TLS provides a fingerprint for Client/Server comms.  However,
        // an active attacker can manipulate this as client/server have no PSK.
        // Therefore, independent check over ToR or VPN will verify.

        // Do nothing right now. 
        // TODO: This should generate a URL, which when accessed through another
        // source, will help verify the Finger for second level TLS.
        // Recommeded via TOR or VPN.

        return Task.FromResult(0);
    }
    async Task Connect() {
        byte[] ikm = System.Text.Encoding.UTF8.GetBytes(passwordInput);

        byte[] info = System.Text.Encoding.UTF8.GetBytes(groupInput);

        // Calculate Channel as Guid. No salt.
        channelId = new Guid(MegolmGroup.HKDF(ikm, 16, null, info));

        // TODO: Session must be encrypted, using password only.
        // AES - HKDF(password, AES + IV, channel, "Password');
        group = new MegolmGroup();
        group.Session.Name = userInput;

        // Maybe a better way to do this, not stopping execution is important.
        Timer();

        byte[] salt = MegolmGroup.GetRandomBytes(32);
        var msg = MegolmGroup.AesCrypt(ikm, salt, info, true, group.Session.Serialize());

        await hubConnection.SendAsync("JoinGroup", channelId);
        await hubConnection.SendAsync("SendSession", channelId, salt, Salinate(salt, group.Session.Serialize()));
        // await hubConnection.SendAsync("SetNick", channelId, salt, Salinate(salt, group.Session.Serialize()));
    }

    private async Task SendMeta() {
        var cipherText = group.Encrypt(System.Text.Encoding.UTF8.GetBytes("ping"));
        StateHasChanged();
        await hubConnection.SendAsync("SendMeta", channelId, group.Session.Key.PublicKeyRaw, cipherText);
    }
    private async void Send(KeyboardEventArgs args) {
        if (args.Key != "Enter" || messageInput == "" || messageInput == null)
            return;
        Console.WriteLine("SendMessage");
        var cipherText = group.Encrypt(System.Text.Encoding.UTF8.GetBytes(messageInput));
        messageInput = null;

        await hubConnection.SendAsync("SendMessage", channelId, group.Session.Key.PublicKeyRaw, cipherText);
    }

    public bool IsConnected =>
        hubConnection.State == HubConnectionState.Connected;
    public bool HasGroup =>
        group != null;

    public void Dispose() {
        _ = hubConnection.DisposeAsync();
    }
}